# 一、版本控制系统
## 1.1 分类
版本控制系统分为集中式版本控制系统和分布式版本控制系统。
## 1.2 集中式版本控制系统
常见的集中式本控制系统（Centralized Version Control Systems，简称 CVCS）有CVS、SubVersion、以及Perforce等，它们的的共同特点是：都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或者提交更新。
## 1.3 分布式版本控制系统
常见的分布式版本控制系统（Distributed Version Control System，简称 DVCS）有Git、Mercurial、Bazaar以及Darcs等，客户端并不只是提取最新版本的文件快照，而是把代码仓库完整的镜像下来。
## 1.4 Git项目的工作区域
Git项目分三个工作区域：Git仓库、工作目录及暂存区域。Git文件根据所处的工作区域分为相应的三个状态：已提交（commited）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存到本地数据库中。已修改表示修改了该文件，但还没有保存到数据库中。已暂存表示对一个已修改的当前版本做了标记，使之包含在下次提交的快照中。
## 1.5 Git仓库
Git仓库目录是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从计算机克隆仓库是，拷贝的就是这里的数据。
## 1.6 工作目录
工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供使用或修改。
## 1.7 暂存区域
暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中，有时候也被成为“索引”，不过一般说法还是叫暂存区域。
## 1.8 Git的基本的工作流程
1. 在工作目录中修改文件。
2. 暂存文件，将文件修改的快照放入暂存区域。
3. 提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。
# 二 Git基本配置
## 2.1 用户信息
安装完Git应该做的第一件事就是设置你的用户名和邮件地址。因为每一次Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：
`git config --global user.name "looper"`
`git config --global user.email looper@example.com`
## 2.2 文本编辑器
配置完用户信息，你就可以配置默认的文本编辑器了，当Git需要输入信息时会调用它。如果未配置，Git会使用操作系统默认的文本编辑器，通常是Vim。如果你想使用不同的文本编辑器，例如Emacs，可以这样做：
`git config --global core.editor emacs`
## 2.3 查看配置信息
如果想要检查你的配置，可以使用如下命令列出所有Git能找到的配置：
`git config --list`
当然你也可以通过如下命令查看Git的某一项配置：
`git config user.name`--查看用户名
## 2.4获取帮助
想要获得config命令的手册，可以执行：
`git help config`
# 三 获取Git仓库
## 3.1 获取Git仓库
获取Git仓库有两种方式：一是在现有项目或目录下导入所有文件到Git中；二是从远程仓库（比如GitHub）克隆一个现有的Git仓库。
## 3.1.1 在现有的目录中初始化仓库
如果你打算使用Git对现有的项目进行管理，你需要通过以下命令进入该项目目录：
`cd D:/project`
然后执行如下命令对该项目进行初始化设置：
`git init`
该命令将创建一个名为.git的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的核心。但这个时候我们仅仅是做了初始化操作，你的项目里的文件没有被跟踪。你可以通过如下命令实现对指定文件的跟踪：
`git add .`
`git commit -m 'first commit'`
现在你已经得到了一个实际维护着若干文件的Git仓库。
## 3.1.2 克隆现有的仓库
如果你想获得一份GitHub上一个开源项目的源码并希望为这个开源项目贡献力量时，这时就要用到git clone命令，Git克隆的是该Git仓库服务器上的几乎所有数据，而不仅仅复制完成你的工作所需文件。当你执行Git clone命令的时候，默认配置型远程Git仓库中的每一个文件的每一个版本都将被拉取下来。克隆仓库的命令为：
`git clone git@github.com:square/okhttp.git`
这会在当前目录下创建一个名为“okhttp”的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：
`git clone git@github.com:square/okhttp.git OkHttp`
这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为OkHttp。
## 3.1.3 Git支持的传输协议
Git支持多种数据传输协议，如Https://,git://协议或者使用SSH传输协议，比如user@server:path/to/repo.git等。
# 四 记录每次更新到仓库
## 4.1 检查当前文件状态
要查看哪些文件处于什么状态，可以使用如下命令：
`git status`
## 4.2 跟踪新文件
如果你在工作目录新建README文件，然后使用git status命令查看文件状态，README文件就会出现在Untracked files下面。未跟踪的文件意味着Git在之前的快照中没有这些文件；Git不会自动将之纳入跟踪范围，除非你明确指出“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其他不想被跟踪的文件包含进来。如果你想把新建的README文件纳入跟踪范围，可以通过如下命令实现：
`git add README`
此时再运行 git status命令，会看到README文件已被跟踪，并处于暂存状态。
git add命令可以理解为“添加内容到下一次提交中”，可以用该命令跟踪新添加的文件，也可以把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。
## 4.3 状态简览
git status命令的输出十分详细，但是显示方式太过繁琐，如果你想得到一种更为紧凑的格式输出，可以使用如下命令：
`git status -s`
新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 
## 4.4 提交更新
现在的暂存区域已经准备妥当等待提交了，可以通过如下命令提交在暂存区保存的修改或添加的内容：
`git commit -m "fix several bug"`
上面的命令是讲本地工作区域要提交的内容提交到远程仓库并添加了这次提交的描述。
## 4.5 跳过使用暂存区域
Git提供了一个跳过使用暂存区域的方式，只要在提交的时候，给git commit加上一个 -a选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤：
`git commit -a -m "skip add step"`
## 4.6 移除文件
要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（确切的说，是从暂存区域移除），然后提交。可以使用git rm命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

```nginx
git rm 'demo.txt' --cached //仅从跟踪清单中删除，亦即从暂存区移除，但仍保留在当前工作目录中
git rm 'demo.txt' -f //从跟踪清单中删除，亦即从暂存区移除，并从工作目录中删除指定的文件
```

## 4.7 撤销操作
在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。
## 4.7.1 取消暂存的文件
如果你已经修改了两个文件并且想要将他们暂存到暂存区域，但是发现其中一个文件有若干错误，不想在本次commit中提交该文件，你可以使用如下命令来取消暂存的文件：
`git reset HEAD Git.md`
这样Git.md文件就取消暂存了。
## 4.7.2 撤销对文件的修改
如果修改了已经暂存的文件，但又做了很大程度的修改，但是你想撤销到原来暂存的版本重新开始修改，此时你可以通过如下命令达到这个目的：
`git check -- Git.md`
执行完该命令，你可以通过git status命令查看所做的修改已经被撤销了。**你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。**
#  五、远程仓库的使用
## 5.1 远程仓库的使用
远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。
## 5.2 查看远程仓库
如果想查看你已经配置的远程仓库服务器，可以运行如下命令：
`git remote`
 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字，你也可以指定选项-v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。
`git remote -v`
如果你的远程仓库不止一个，该命令会将它们全部列出。
## 5.3 添加远程仓库
运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：
`git remote add okhttp git@github.com:square/okhttp.git`
现在你可以在命令行中使用字符串 okhttp 来代替整个 URL。 例如，如果你想拉取 okhttp 的仓库中有但你没有的信息，可以运行：
`git fetch okhttp`
如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
## 5.4 推送到远程仓库
当你想分享你的项目时，必须将其推送到上游。当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：
`git push origin master`
只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。
## 5.5 查看远程仓库
如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin：
`git remote show origin`
## 5.6 远程仓库的移除与重命名
如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 okhttp 重命名为 Okhttp，可以用 git remote rename 这样做：
`git remote rename okhttp Okhttp`
值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 okhttp/master 的现在会引用 Okhttp/master。
如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了,可以使用 `git remote rm okhttp`
 ## 5.7 打标签
像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
## 5.7.1 列出标签
在 Git 中列出已有的标签是非常简单直观的。 只需要输入：
`git tag`
这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。
## 5.7.2 创建标签
Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。
# 六、GitHub
## 6.1 派生(Fork)项目
如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项目进行“派生”。 派生的意思是指，GitHub 将在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。通过这种方式，项目的管理者不再需要忙着把用户添加到贡献者列表并给予他们推送权限。 人们可以派生这个项目，将修改推送到派生出的项目副本中，并通过创建合并请求（Pull Request）来让他们的改动进入源版本库，下文我们会详细说明。 创建了合并请求后，就会开启一个可供审查代码的板块，项目的拥有者和贡献者可以在此讨论相关修改，直到项目拥有者对其感到满意，并且认为这些修改可以被合并到版本库。
## 6.2 GitHub流程
1. 从 master 分支中创建一个新分支
2. 提交一些修改来改进项目
3. 将这个分支推送到 GitHub 上
4. 创建一个合并请求
5. 讨论，根据实际情况继续修改
6. 项目的拥有者合并或关闭你的合并请求